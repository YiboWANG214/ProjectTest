[
{
    "id": "chatcmpl-B2mjMwb0FlCx3zYuQDXo0pJrbukqJ",
    "object": "chat.completion",
    "created": 1740003676,
    "model": "gpt-3.5-turbo-0125",
    "choices": [
        {
            "index": 0,
            "message": {
                "role": "assistant",
                "content": "```python\n# test_uno_round.py\n\nimport unittest\nfrom uno.round import UnoRound\nfrom uno.card import UnoCard\n\nclass TestUnoRound(unittest.TestCase):\n\n    def setUp(self):\n        self.round = UnoRound(None, 2, np_random=None)\n        self.players = [UnoPlayer(0, np_random=None), UnoPlayer(1, np_random=None)]\n\n    def test_flip_top_card(self):\n        top_card = self.round.flip_top_card()\n        self.assertIsInstance(top_card, UnoCard)\n\n    def test_perform_top_card(self):\n        top_card = UnoCard('number', 'r', '3')\n        self.round.perform_top_card(self.players, top_card)\n        self.assertEqual(self.round.current_player, 1)\n        self.assertEqual(self.round.direction, 1)\n\n    def test_proceed_round(self):\n        top_card = UnoCard('number', 'r', '3')\n        self.round.target = top_card\n        self.round.current_player = 0\n        self.round.proceed_round(self.players, 'r-3')\n        self.assertEqual(self.round.current_player, 1)\n\n    def test_get_legal_actions(self):\n        top_card = UnoCard('number', 'r', '3')\n        self.round.target = top_card\n        self.players[0].hand = [UnoCard('number', 'r', '2')]\n        legal_actions = self.round.get_legal_actions(self.players, 0)\n        self.assertListEqual(legal_actions, ['r-2'])\n\n    def test_get_state(self):\n        top_card = UnoCard('number', 'r', '3')\n        self.round.target = top_card\n        self.players[0].hand = [UnoCard('number', 'r', '2')]\n        state = self.round.get_state(self.players, 0)\n        self.assertIn('hand', state)\n        self.assertIn('target', state)\n        self.assertIn('played_cards', state)\n        self.assertIn('legal_actions', state)\n        self.assertIn('num_cards', state)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_dealer.py\n\nimport unittest\nfrom uno.dealer import UnoDealer\n\nclass TestUnoDealer(unittest.TestCase):\n\n    def setUp(self):\n        self.dealer = UnoDealer(np_random=None)\n\n    def test_shuffle(self):\n        deck_before = self.dealer.deck[:]\n        self.dealer.shuffle()\n        deck_after = self.dealer.deck\n        self.assertNotEqual(deck_before, deck_after)\n\n    def test_deal_cards(self):\n        player = UnoPlayer(0, np_random=None)\n        num = 3\n        self.dealer.deal_cards(player, num)\n        self.assertEqual(len(player.hand), num)\n\n    def test_flip_top_card(self):\n        top_card = self.dealer.flip_top_card()\n        self.assertIsNotNone(top_card)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_player.py\n\nimport unittest\nfrom uno.player import UnoPlayer\n\nclass TestUnoPlayer(unittest.TestCase):\n\n    def setUp(self):\n        self.player = UnoPlayer(0, np_random=None)\n\n    def test_get_player_id(self):\n        player_id = self.player.get_player_id()\n        self.assertEqual(player_id, 0)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_game.py\n\nimport unittest\nfrom uno.game import UnoGame\n\nclass TestUnoGame(unittest.TestCase):\n\n    def setUp(self):\n        self.game = UnoGame(allow_step_back=False, num_players=2)\n\n    def test_configure(self):\n        game_config = {'game_num_players': 2}\n        self.game.configure(game_config)\n        self.assertEqual(self.game.num_players, 2)\n\n    def test_get_num_players(self):\n        num_players = self.game.get_num_players()\n        self.assertEqual(num_players, 2)\n\n    def test_get_num_actions(self):\n        num_actions = UnoGame.get_num_actions()\n        self.assertEqual(num_actions, 61)\n\n    def test_get_legal_actions(self):\n        legal_actions = self.game.get_legal_actions()\n        self.assertIsInstance(legal_actions, list)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_judger.py\n\nimport unittest\nfrom uno.judger import UnoJudger\n\nclass TestUnoJudger(unittest.TestCase):\n\n    def setUp(self):\n        self.players = [UnoPlayer(0, np_random=None), UnoPlayer(1, np_random=None)]\n\n    def test_judge_winner(self):\n        np_random = None\n        winner = UnoJudger.judge_winner(self.players, np_random)\n        self.assertIsInstance(winner, list)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_card.py\n\nimport unittest\nfrom uno.card import UnoCard\n\nclass TestUnoCard(unittest.TestCase):\n\n    def test_get_str(self):\n        card = UnoCard('number', 'r', '3')\n        card_str = card.get_str()\n        self.assertEqual(card_str, 'r-3')\n\n    def test_print_cards(self):\n        cards = ['r-0', 'g-skip']\n        UnoCard.print_cards(cards, wild_color=False)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_utils.py\n\nimport unittest\nfrom uno.utils import init_deck, cards2list, hand2dict, encode_hand, encode_target\n\nclass TestUtils(unittest.TestCase):\n\n    def test_init_deck(self):\n        deck = init_deck()\n        self.assertEqual(len(deck), 108)\n\n    def test_cards2list(self):\n        hand = ['r-0', 'g-3']\n        cards_list = cards2list(hand)\n        self.assertIsInstance(cards_list, list)\n\n    def test_hand2dict(self):\n        hand = ['r-0', 'g-3']\n        hand_dict = hand2dict(hand)\n        self.assertIsInstance(hand_dict, dict)\n\n    def test_encode_hand(self):\n        hand = ['r-0', 'g-3']\n        plane = encode_hand(np.zeros((3, 4, 15), dtype=int), hand)\n        self.assertIsInstance(plane, np.ndarray)\n\n    def test_encode_target(self):\n        target = 'r-0'\n        plane = encode_target(np.zeros((1, 4, 15), dtype=int), target)\n        self.assertIsInstance(plane, np.ndarray)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n```python\n# test_uno_init.py\n\nimport unittest\nfrom uno import Dealer, Judger, Player, Round, Game\n\nclass TestUnoInit(unittest.TestCase):\n\n    def test_imports(self):\n        self.assertTrue(Dealer)\n        self.assertTrue(Judger)\n        self.assertTrue(Player)\n        self.assertTrue(Round)\n        self.assertTrue(Game)\n\nif __name__ == '__main__':\n    unittest.main()\n```",
                "refusal": null
            },
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 4854,
        "completion_tokens": 1415,
        "total_tokens": 6269,
        "prompt_tokens_details": {
            "cached_tokens": 0,
            "audio_tokens": 0
        },
        "completion_tokens_details": {
            "reasoning_tokens": 0,
            "audio_tokens": 0,
            "accepted_prediction_tokens": 0,
            "rejected_prediction_tokens": 0
        }
    },
    "service_tier": "default",
    "system_fingerprint": null,
    "time_taken": 14.152941465377808,
    "prompt_id": "./ProjectTest/Python/uno.py",
    "original_code": "'''\nuno/player.py\n'''\n\nclass UnoPlayer:\n\n    def __init__(self, player_id, np_random):\n        ''' Initilize a player.\n\n        Args:\n            player_id (int): The id of the player\n        '''\n        self.np_random = np_random\n        self.player_id = player_id\n        self.hand = []\n        self.stack = []\n\n    def get_player_id(self):\n        ''' Return the id of the player\n        '''\n\n        return self.player_id\n\n\n'''\nuno/dealer.py\n'''\n\nfrom utils import init_deck\n\n\nclass UnoDealer:\n    ''' Initialize a uno dealer class\n    '''\n    def __init__(self, np_random):\n        self.np_random = np_random\n        self.deck = init_deck()\n        self.shuffle()\n\n    def shuffle(self):\n        ''' Shuffle the deck\n        '''\n        self.np_random.shuffle(self.deck)\n\n    def deal_cards(self, player, num):\n        ''' Deal some cards from deck to one player\n\n        Args:\n            player (object): The object of DoudizhuPlayer\n            num (int): The number of cards to be dealed\n        '''\n        for _ in range(num):\n            player.hand.append(self.deck.pop())\n\n    def flip_top_card(self):\n        ''' Flip top card when a new game starts\n\n        Returns:\n            (object): The object of UnoCard at the top of the deck\n        '''\n        top_card = self.deck.pop()\n        while top_card.trait == 'wild_draw_4':\n            self.deck.append(top_card)\n            self.shuffle()\n            top_card = self.deck.pop()\n        return top_card\n\n\n'''\nuno/card.py\n'''\nfrom termcolor import colored\n\nclass UnoCard:\n\n    info = {'type':  ['number', 'action', 'wild'],\n            'color': ['r', 'g', 'b', 'y'],\n            'trait': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n                      'skip', 'reverse', 'draw_2', 'wild', 'wild_draw_4']\n            }\n\n    def __init__(self, card_type, color, trait):\n        ''' Initialize the class of UnoCard\n\n        Args:\n            card_type (str): The type of card\n            color (str): The color of card\n            trait (str): The trait of card\n        '''\n        self.type = card_type\n        self.color = color\n        self.trait = trait\n        self.str = self.get_str()\n\n    def get_str(self):\n        ''' Get the string representation of card\n\n        Return:\n            (str): The string of card's color and trait\n        '''\n        return self.color + '-' + self.trait\n\n\n    @staticmethod\n    def print_cards(cards, wild_color=False):\n        ''' Print out card in a nice form\n\n        Args:\n            card (str or list): The string form or a list of a UNO card\n            wild_color (boolean): True if assign collor to wild cards\n        '''\n        if isinstance(cards, str):\n            cards = [cards]\n        for i, card in enumerate(cards):\n            if card == 'draw':\n                trait = 'Draw'\n            else:\n                color, trait = card.split('-')\n                if trait == 'skip':\n                    trait = 'Skip'\n                elif trait == 'reverse':\n                    trait = 'Reverse'\n                elif trait == 'draw_2':\n                    trait = 'Draw-2'\n                elif trait == 'wild':\n                    trait = 'Wild'\n                elif trait == 'wild_draw_4':\n                    trait = 'Wild-Draw-4'\n\n            if trait == 'Draw' or (trait[:4] == 'Wild' and not wild_color):\n                print(trait, end='')\n            elif color == 'r':\n                print(colored(trait, 'red'), end='')\n            elif color == 'g':\n                print(colored(trait, 'green'), end='')\n            elif color == 'b':\n                print(colored(trait, 'blue'), end='')\n            elif color == 'y':\n                print(colored(trait, 'yellow'), end='')\n\n            if i < len(cards) - 1:\n                print(', ', end='')\n\n\n'''\nuno/judger.py\n'''\n\nclass UnoJudger:\n\n    @staticmethod\n    def judge_winner(players, np_random):\n        ''' Judge the winner of the game\n\n        Args:\n            players (list): The list of players who play the game\n\n        Returns:\n            (list): The player id of the winner\n        '''\n        count_1 = len(players[0].hand)\n        count_2 = len(players[1].hand)\n        if count_1 == count_2:\n            return [0, 1]\n        if count_1 < count_2:\n            return [0]\n        return [1]\n\n\n'''\nuno/game.py\n'''\nfrom copy import deepcopy\nimport numpy as np\n\nfrom uno import Dealer\nfrom uno import Player\nfrom uno import Round\n\n\nclass UnoGame:\n\n    def __init__(self, allow_step_back=False, num_players=2):\n        self.allow_step_back = allow_step_back\n        self.np_random = np.random.RandomState()\n        self.num_players = num_players\n        self.payoffs = [0 for _ in range(self.num_players)]\n\n    def configure(self, game_config):\n        ''' Specifiy some game specific parameters, such as number of players\n        '''\n        self.num_players = game_config['game_num_players']\n\n    def init_game(self):\n        ''' Initialize players and state\n\n        Returns:\n            (tuple): Tuple containing:\n\n                (dict): The first state in one game\n                (int): Current player's id\n        '''\n        # Initalize payoffs\n        self.payoffs = [0 for _ in range(self.num_players)]\n\n        # Initialize a dealer that can deal cards\n        self.dealer = Dealer(self.np_random)\n\n        # Initialize four players to play the game\n        self.players = [Player(i, self.np_random) for i in range(self.num_players)]\n\n        # Deal 7 cards to each player to prepare for the game\n        for player in self.players:\n            self.dealer.deal_cards(player, 7)\n\n        # Initialize a Round\n        self.round = Round(self.dealer, self.num_players, self.np_random)\n\n        # flip and perfrom top card\n        top_card = self.round.flip_top_card()\n        self.round.perform_top_card(self.players, top_card)\n\n        # Save the hisory for stepping back to the last state.\n        self.history = []\n\n        player_id = self.round.current_player\n        state = self.get_state(player_id)\n        return state, player_id\n\n    def step(self, action):\n        ''' Get the next state\n\n        Args:\n            action (str): A specific action\n\n        Returns:\n            (tuple): Tuple containing:\n\n                (dict): next player's state\n                (int): next plater's id\n        '''\n\n        if self.allow_step_back:\n            # First snapshot the current state\n            his_dealer = deepcopy(self.dealer)\n            his_round = deepcopy(self.round)\n            his_players = deepcopy(self.players)\n            self.history.append((his_dealer, his_players, his_round))\n\n        self.round.proceed_round(self.players, action)\n        player_id = self.round.current_player\n        state = self.get_state(player_id)\n        return state, player_id\n\n    def step_back(self):\n        ''' Return to the previous state of the game\n\n        Returns:\n            (bool): True if the game steps back successfully\n        '''\n        if not self.history:\n            return False\n        self.dealer, self.players, self.round = self.history.pop()\n        return True\n\n    def get_state(self, player_id):\n        ''' Return player's state\n\n        Args:\n            player_id (int): player id\n\n        Returns:\n            (dict): The state of the player\n        '''\n        state = self.round.get_state(self.players, player_id)\n        state['num_players'] = self.get_num_players()\n        state['current_player'] = self.round.current_player\n        return state\n\n    def get_payoffs(self):\n        ''' Return the payoffs of the game\n\n        Returns:\n            (list): Each entry corresponds to the payoff of one player\n        '''\n        winner = self.round.winner\n        if winner is not None and len(winner) == 1:\n            self.payoffs[winner[0]] = 1\n            self.payoffs[1 - winner[0]] = -1\n        return self.payoffs\n\n    def get_legal_actions(self):\n        ''' Return the legal actions for current player\n\n        Returns:\n            (list): A list of legal actions\n        '''\n\n        return self.round.get_legal_actions(self.players, self.round.current_player)\n\n    def get_num_players(self):\n        ''' Return the number of players in Limit Texas Hold'em\n\n        Returns:\n            (int): The number of players in the game\n        '''\n        return self.num_players\n\n    @staticmethod\n    def get_num_actions():\n        ''' Return the number of applicable actions\n\n        Returns:\n            (int): The number of actions. There are 61 actions\n        '''\n        return 61\n\n    def get_player_id(self):\n        ''' Return the current player's id\n\n        Returns:\n            (int): current player's id\n        '''\n        return self.round.current_player\n\n    def is_over(self):\n        ''' Check if the game is over\n\n        Returns:\n            (boolean): True if the game is over\n        '''\n        return self.round.is_over\n\n\n'''\nuno/utils.py\n'''\nimport os\nimport json\nimport numpy as np\nfrom collections import OrderedDict\n\nimport rlcard\n\nfrom uno.card import UnoCard as Card\n\n# Read required docs\nROOT_PATH = rlcard.__path__[0]\n\n# a map of abstract action to its index and a list of abstract action\nwith open(os.path.join(ROOT_PATH, 'games/uno/jsondata/action_space.json'), 'r') as file:\n    ACTION_SPACE = json.load(file, object_pairs_hook=OrderedDict)\n    ACTION_LIST = list(ACTION_SPACE.keys())\n\n# a map of color to its index\nCOLOR_MAP = {'r': 0, 'g': 1, 'b': 2, 'y': 3}\n\n# a map of trait to its index\nTRAIT_MAP = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,\n             '8': 8, '9': 9, 'skip': 10, 'reverse': 11, 'draw_2': 12,\n             'wild': 13, 'wild_draw_4': 14}\n\nWILD = ['r-wild', 'g-wild', 'b-wild', 'y-wild']\n\nWILD_DRAW_4 = ['r-wild_draw_4', 'g-wild_draw_4', 'b-wild_draw_4', 'y-wild_draw_4']\n\n\ndef init_deck():\n    ''' Generate uno deck of 108 cards\n    '''\n    deck = []\n    card_info = Card.info\n    for color in card_info['color']:\n\n        # init number cards\n        for num in card_info['trait'][:10]:\n            deck.append(Card('number', color, num))\n            if num != '0':\n                deck.append(Card('number', color, num))\n\n        # init action cards\n        for action in card_info['trait'][10:13]:\n            deck.append(Card('action', color, action))\n            deck.append(Card('action', color, action))\n\n        # init wild cards\n        for wild in card_info['trait'][-2:]:\n            deck.append(Card('wild', color, wild))\n    return deck\n\n\ndef cards2list(cards):\n    ''' Get the corresponding string representation of cards\n\n    Args:\n        cards (list): list of UnoCards objects\n\n    Returns:\n        (string): string representation of cards\n    '''\n    cards_list = []\n    for card in cards:\n        cards_list.append(card.get_str())\n    return cards_list\n\ndef hand2dict(hand):\n    ''' Get the corresponding dict representation of hand\n\n    Args:\n        hand (list): list of string of hand's card\n\n    Returns:\n        (dict): dict of hand\n    '''\n    hand_dict = {}\n    for card in hand:\n        if card not in hand_dict:\n            hand_dict[card] = 1\n        else:\n            hand_dict[card] += 1\n    return hand_dict\n\ndef encode_hand(plane, hand):\n    ''' Encode hand and represerve it into plane\n\n    Args:\n        plane (array): 3*4*15 numpy array\n        hand (list): list of string of hand's card\n\n    Returns:\n        (array): 3*4*15 numpy array\n    '''\n    # plane = np.zeros((3, 4, 15), dtype=int)\n    plane[0] = np.ones((4, 15), dtype=int)\n    hand = hand2dict(hand)\n    for card, count in hand.items():\n        card_info = card.split('-')\n        color = COLOR_MAP[card_info[0]]\n        trait = TRAIT_MAP[card_info[1]]\n        if trait >= 13:\n            if plane[1][0][trait] == 0:\n                for index in range(4):\n                    plane[0][index][trait] = 0\n                    plane[1][index][trait] = 1\n        else:\n            plane[0][color][trait] = 0\n            plane[count][color][trait] = 1\n    return plane\n\ndef encode_target(plane, target):\n    ''' Encode target and represerve it into plane\n\n    Args:\n        plane (array): 1*4*15 numpy array\n        target(str): string of target card\n\n    Returns:\n        (array): 1*4*15 numpy array\n    '''\n    target_info = target.split('-')\n    color = COLOR_MAP[target_info[0]]\n    trait = TRAIT_MAP[target_info[1]]\n    plane[color][trait] = 1\n    return plane\n\n\n'''\nuno/__init__.py\n'''\nfrom uno.dealer import UnoDealer as Dealer\nfrom uno.judger import UnoJudger as Judger\nfrom uno.player import UnoPlayer as Player\nfrom uno.round import UnoRound as Round\nfrom uno.game import UnoGame as Game\n\n\n\n'''\nuno/round.py\n'''\nfrom card import UnoCard\nfrom utils import cards2list, WILD, WILD_DRAW_4\n\n\nclass UnoRound:\n\n    def __init__(self, dealer, num_players, np_random):\n        ''' Initialize the round class\n\n        Args:\n            dealer (object): the object of UnoDealer\n            num_players (int): the number of players in game\n        '''\n        self.np_random = np_random\n        self.dealer = dealer\n        self.target = None\n        self.current_player = 0\n        self.num_players = num_players\n        self.direction = 1\n        self.played_cards = []\n        self.is_over = False\n        self.winner = None\n\n    def flip_top_card(self):\n        ''' Flip the top card of the card pile\n\n        Returns:\n            (object of UnoCard): the top card in game\n\n        '''\n        top = self.dealer.flip_top_card()\n        if top.trait == 'wild':\n            top.color = self.np_random.choice(UnoCard.info['color'])\n        self.target = top\n        self.played_cards.append(top)\n        return top\n\n    def perform_top_card(self, players, top_card):\n        ''' Perform the top card\n\n        Args:\n            players (list): list of UnoPlayer objects\n            top_card (object): object of UnoCard\n        '''\n        if top_card.trait == 'skip':\n            self.current_player = 1\n        elif top_card.trait == 'reverse':\n            self.direction = -1\n            self.current_player = (0 + self.direction) % self.num_players\n        elif top_card.trait == 'draw_2':\n            player = players[self.current_player]\n            self.dealer.deal_cards(player, 2)\n\n    def proceed_round(self, players, action):\n        ''' Call other Classes' functions to keep one round running\n\n        Args:\n            player (object): object of UnoPlayer\n            action (str): string of legal action\n        '''\n        if action == 'draw':\n            self._perform_draw_action(players)\n            return None\n        player = players[self.current_player]\n        card_info = action.split('-')\n        color = card_info[0]\n        trait = card_info[1]\n        # remove corresponding card\n        remove_index = None\n        if trait == 'wild' or trait == 'wild_draw_4':\n            for index, card in enumerate(player.hand):\n                if trait == card.trait:\n                    card.color = color # update the color of wild card to match the action\n                    remove_index = index\n                    break\n        else:\n            for index, card in enumerate(player.hand):\n                if color == card.color and trait == card.trait:\n                    remove_index = index\n                    break\n        card = player.hand.pop(remove_index)\n        if not player.hand:\n            self.is_over = True\n            self.winner = [self.current_player]\n        self.played_cards.append(card)\n\n        # perform the number action\n        if card.type == 'number':\n            self.current_player = (self.current_player + self.direction) % self.num_players\n            self.target = card\n\n        # perform non-number action\n        else:\n            self._preform_non_number_action(players, card)\n\n    def get_legal_actions(self, players, player_id):\n        wild_flag = 0\n        wild_draw_4_flag = 0\n        legal_actions = []\n        wild_4_actions = []\n        hand = players[player_id].hand\n        target = self.target\n        if target.type == 'wild':\n            for card in hand:\n                if card.type == 'wild':\n                    if card.trait == 'wild_draw_4':\n                        if wild_draw_4_flag == 0:\n                            wild_draw_4_flag = 1\n                            wild_4_actions.extend(WILD_DRAW_4)\n                    else:\n                        if wild_flag == 0:\n                            wild_flag = 1\n                            legal_actions.extend(WILD)\n                elif card.color == target.color:\n                    legal_actions.append(card.str)\n\n        # target is aciton card or number card\n        else:\n            for card in hand:\n                if card.type == 'wild':\n                    if card.trait == 'wild_draw_4':\n                        if wild_draw_4_flag == 0:\n                            wild_draw_4_flag = 1\n                            wild_4_actions.extend(WILD_DRAW_4)\n                    else:\n                        if wild_flag == 0:\n                            wild_flag = 1\n                            legal_actions.extend(WILD)\n                elif card.color == target.color or card.trait == target.trait:\n                    legal_actions.append(card.str)\n        if not legal_actions:\n            legal_actions = wild_4_actions\n        if not legal_actions:\n            legal_actions = ['draw']\n        return legal_actions\n\n    def get_state(self, players, player_id):\n        ''' Get player's state\n\n        Args:\n            players (list): The list of UnoPlayer\n            player_id (int): The id of the player\n        '''\n        state = {}\n        player = players[player_id]\n        state['hand'] = cards2list(player.hand)\n        state['target'] = self.target.str\n        state['played_cards'] = cards2list(self.played_cards)\n        state['legal_actions'] = self.get_legal_actions(players, player_id)\n        state['num_cards'] = []\n        for player in players:\n            state['num_cards'].append(len(player.hand))\n        return state\n\n    def replace_deck(self):\n        ''' Add cards have been played to deck\n        '''\n        self.dealer.deck.extend(self.played_cards)\n        self.dealer.shuffle()\n        self.played_cards = []\n\n    def _perform_draw_action(self, players):\n        # replace deck if there is no card in draw pile\n        if not self.dealer.deck:\n            self.replace_deck()\n            #self.is_over = True\n            #self.winner = UnoJudger.judge_winner(players)\n            #return None\n\n        card = self.dealer.deck.pop()\n\n        # draw a wild card\n        if card.type == 'wild':\n            card.color = self.np_random.choice(UnoCard.info['color'])\n            self.target = card\n            self.played_cards.append(card)\n            self.current_player = (self.current_player + self.direction) % self.num_players\n\n        # draw a card with the same color of target\n        elif card.color == self.target.color:\n            if card.type == 'number':\n                self.target = card\n                self.played_cards.append(card)\n                self.current_player = (self.current_player + self.direction) % self.num_players\n            else:\n                self.played_cards.append(card)\n                self._preform_non_number_action(players, card)\n\n        # draw a card with the diffrent color of target\n        else:\n            players[self.current_player].hand.append(card)\n            self.current_player = (self.current_player + self.direction) % self.num_players\n\n    def _preform_non_number_action(self, players, card):\n        current = self.current_player\n        direction = self.direction\n        num_players = self.num_players\n\n        # perform reverse card\n        if card.trait == 'reverse':\n            self.direction = -1 * direction\n\n        # perfrom skip card\n        elif card.trait == 'skip':\n            current = (current + direction) % num_players\n\n        # perform draw_2 card\n        elif card.trait == 'draw_2':\n            if len(self.dealer.deck) < 2:\n                self.replace_deck()\n                #self.is_over = True\n                #self.winner = UnoJudger.judge_winner(players)\n                #return None\n            self.dealer.deal_cards(players[(current + direction) % num_players], 2)\n            current = (current + direction) % num_players\n\n        # perfrom wild_draw_4 card\n        elif card.trait == 'wild_draw_4':\n            if len(self.dealer.deck) < 4:\n                self.replace_deck()\n                #self.is_over = True\n                #self.winner = UnoJudger.judge_winner(players)\n                #return None\n            self.dealer.deal_cards(players[(current + direction) % num_players], 4)\n            current = (current + direction) % num_players\n        self.current_player = (current + self.direction) % num_players\n        self.target = card\n\n\n",
    "test_prompt": "Please generate enough unit test cases for each python file in the uno project. Ensure that the import path is correct, depending on whether the project is structured as a package. Make sure the tests can successfully compile. Make sure the tests have correct results. Try to achieve the highest coverage rate. \n\n"
}
]
