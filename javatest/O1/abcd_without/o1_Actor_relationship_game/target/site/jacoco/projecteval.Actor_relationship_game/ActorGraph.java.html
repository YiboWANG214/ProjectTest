<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ActorGraph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">o1Actor_relationship_game</a> &gt; <a href="index.source.html" class="el_package">projecteval.Actor_relationship_game</a> &gt; <span class="el_source">ActorGraph.java</span></div><h1>ActorGraph.java</h1><pre class="source lang-java linenums">package projecteval.Actor_relationship_game;

import java.io.Serializable;
import java.util.*;

public class ActorGraph implements Serializable {
    private static final long serialVersionUID=1L;
    private Map&lt;String, Actor&gt; actors;
    private Map&lt;String, Movie&gt; movies;
    private Map&lt;String, String&gt; nameToIdMap;
    private Map&lt;String, String&gt; idToNameMap;

<span class="fc" id="L13">    public ActorGraph() {</span>
<span class="fc" id="L14">        this.actors = new HashMap&lt;&gt;();</span>
<span class="fc" id="L15">        this.movies = new HashMap&lt;&gt;();</span>
<span class="fc" id="L16">        this.nameToIdMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L17">        this.idToNameMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L18">    }</span>

    // getters
    public Map&lt;String, Actor&gt; getActors() {
<span class="nc" id="L22">        return actors;</span>
    }
    public Map&lt;String, Movie&gt; getMovies() {
<span class="fc" id="L25">        return movies;</span>
    }
    public Map&lt;String, String&gt; getIdToNameMap() {
<span class="nc" id="L28">        return idToNameMap;</span>
    }
    public Map&lt;String, String&gt; getNameToIdMap() {
<span class="nc" id="L31">        return nameToIdMap;</span>
    }
    public static long getSerialVersionUID() {
<span class="nc" id="L34">        return serialVersionUID;</span>
    }

    // Methods
    public void addActor(Actor actor) {
<span class="fc" id="L39">        actors.putIfAbsent(actor.getId(), actor);</span>
<span class="fc" id="L40">        nameToIdMap.put(actor.getName(), actor.getId());</span>
<span class="fc" id="L41">        idToNameMap.put(actor.getId(), actor.getName());</span>
<span class="fc" id="L42">    }</span>

    public void addMovie(Movie movie) {
<span class="fc" id="L45">        movies.putIfAbsent(movie.getId(), movie);</span>
<span class="fc" id="L46">    }</span>

    public String getActorIdByName(String name) {
<span class="fc" id="L49">        return nameToIdMap.get(name);</span>
    }

    public String getActorNameById(String id) {
<span class="fc" id="L53">        return idToNameMap.get(id);</span>
    }

    public List&lt;String&gt; getAllActorNames() {
<span class="fc" id="L57">        return new ArrayList&lt;&gt;(nameToIdMap.keySet());</span>
    }

    /**
     * This connects an actor to a movie.
     * It's useful for building the graph based on TMDB API data.
     */
    public void addActorToMovie(String actorId, String movieId) {
<span class="pc bpc" id="L65" title="2 of 4 branches missed.">        if (actors.containsKey(actorId) &amp;&amp; movies.containsKey(movieId)) {</span>
<span class="fc" id="L66">            Actor actor = actors.get(actorId);</span>
<span class="fc" id="L67">            Movie movie = movies.get(movieId);</span>
<span class="fc" id="L68">            actor.getMovieIds().add(movieId);</span>
<span class="fc" id="L69">            movie.getActorIds().add(actorId);</span>
        }
<span class="fc" id="L71">    }</span>

    /**
     * Implements BFS to find the shortest path from startActorId to endActorId.
     * It uses a queue for BFS and a map (visited) to track the visited actors and their previous actor in the path.
     */
    public List&lt;Map.Entry&lt;String, String&gt;&gt; findConnectionWithPath(String startActorId, String endActorId) {
<span class="pc bpc" id="L78" title="2 of 4 branches missed.">        if (!actors.containsKey(startActorId) || !actors.containsKey(endActorId)) {</span>
<span class="nc" id="L79">            return Collections.emptyList();</span>
        }

<span class="fc" id="L82">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L83">        Map&lt;String, String&gt; visited = new HashMap&lt;&gt;();</span>
<span class="fc" id="L84">        Map&lt;String, String&gt; previousMovie = new HashMap&lt;&gt;();</span>
<span class="fc" id="L85">        queue.add(startActorId);</span>
<span class="fc" id="L86">        visited.put(startActorId, null);</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">        while (!queue.isEmpty()) {</span>
<span class="fc" id="L89">            String currentActorId = queue.poll();</span>
<span class="fc" id="L90">            Actor currentActor = actors.get(currentActorId);</span>

<span class="fc bfc" id="L92" title="All 2 branches covered.">            for (String movieId : currentActor.getMovieIds()) {</span>
<span class="fc" id="L93">                Movie movie = movies.get(movieId);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                for (String coActorId : movie.getActorIds()) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                    if (!visited.containsKey(coActorId)) {</span>
<span class="fc" id="L96">                        visited.put(coActorId, currentActorId);</span>
<span class="fc" id="L97">                        previousMovie.put(coActorId, movieId);</span>
<span class="fc" id="L98">                        queue.add(coActorId);</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">                        if (coActorId.equals(endActorId)) {</span>
<span class="fc" id="L101">                            return buildPath(visited, previousMovie, endActorId);</span>
                        }
                    }
<span class="fc" id="L104">                }</span>
<span class="fc" id="L105">            }</span>
<span class="fc" id="L106">        }</span>

<span class="fc" id="L108">        return Collections.emptyList();</span>
    }

    /**
     * Helper method to construct the path from the endActorId back to the startActorId using the visited map.
     */
    private List&lt;Map.Entry&lt;String, String&gt;&gt; buildPath(Map&lt;String, String&gt; visited, Map&lt;String, String&gt; previousMovie, String endActorId) {
<span class="fc" id="L115">        LinkedList&lt;Map.Entry&lt;String, String&gt;&gt; path = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L116">        String current = endActorId;</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        while (current != null) {</span>
<span class="fc" id="L118">            String movieId = previousMovie.get(current);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            String movieName = (movieId != null) ? movies.get(movieId).getTitle() : &quot;Start&quot;;</span>
<span class="fc" id="L120">            path.addFirst(new AbstractMap.SimpleEntry&lt;&gt;(idToNameMap.get(current), movieName));</span>
<span class="fc" id="L121">            current = visited.get(current);</span>
<span class="fc" id="L122">        }</span>
<span class="fc" id="L123">        return path;</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>